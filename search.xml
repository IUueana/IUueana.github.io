<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AD20学习笔记1</title>
      <link href="2021/04/18/AD20note/"/>
      <url>2021/04/18/AD20note/</url>
      
        <content type="html"><![CDATA[<p>学习AD时间挺长了！！整理一下学习笔记</p><span id="more"></span><h5 id="1-原理图图纸的设置"><a href="#1-原理图图纸的设置" class="headerlink" title="1.原理图图纸的设置"></a>1.原理图图纸的设置</h5><blockquote><p>   1.双击图纸边缘，进入properties，可以对图纸进行设置，依次表格大小，图纸颜色，图纸大小，方向，标注，以及边缘空白设置。</p></blockquote><h5 id="2-阵列式粘贴"><a href="#2-阵列式粘贴" class="headerlink" title="2.阵列式粘贴:"></a>2.阵列式粘贴:</h5><blockquote><p>   1.ctrl+c 阵列式粘贴  点位置（快捷键 EY）</p></blockquote><h5 id="3-对齐："><a href="#3-对齐：" class="headerlink" title="3.对齐："></a>3.对齐：</h5><blockquote><p>   A+</p></blockquote><h5 id="4-原理图统一标注："><a href="#4-原理图统一标注：" class="headerlink" title="4.原理图统一标注："></a>4.原理图统一标注：</h5><blockquote><p>   1.T+A+A  先复位再更新（处理顺序，那一页，起始索引1+打勾，reset all +更新更改列表）</p></blockquote><h5 id="5-编译选项：编译检查：c-o进入error-reporting-设置下列选项为致命错误"><a href="#5-编译选项：编译检查：c-o进入error-reporting-设置下列选项为致命错误" class="headerlink" title="5.编译选项：编译检查：c+o进入error reporting 设置下列选项为致命错误"></a>5.编译选项：编译检查：c+o进入error reporting 设置下列选项为致命错误</h5><blockquote><p>   1.悬浮的网络标号 floating net labels<br>    2.开路 floating power objects<br>    3.单端网络 Nets with only one pin<br>    4.重复的位号 Duplicate part Designators<br>    5.重复的网络 Duplicate net 特殊情况除外<br>    6.编译(C的第一个选项或者右击工程第一个选项），根据Message检查排除问题</p></blockquote><h5 id="6-封装库管理器TG-："><a href="#6-封装库管理器TG-：" class="headerlink" title="6.封装库管理器TG ："></a>6.封装库管理器TG ：</h5><blockquote><p>   可以检查位号错误，添加封装。</p></blockquote><h5 id="7-高亮："><a href="#7-高亮：" class="headerlink" title="7.高亮："></a>7.高亮：</h5><blockquote><p>   CTRL+单击鼠标</p></blockquote><h5 id="8-PCB封装创建"><a href="#8-PCB封装创建" class="headerlink" title="8.PCB封装创建"></a>8.PCB封装创建</h5><blockquote><p>   1.贴片电阻电容（Q可以改变单位    mil-mm）<br>    2.放置焊盘——更改层（top layer）——改变SHAPE(焊盘形状）<br>    3.复制焊盘：ctrl+c后按住ctrl+v拖动复制<br>    4.M移动：选中原件按M移动<br>    5.丝印是Top overlay,焊盘是top layer<br>    6.原点移动到封装中心EFC,封装画好后<br>    7.PL画线</p></blockquote><h5 id="9-PCB图生成PCB库："><a href="#9-PCB图生成PCB库：" class="headerlink" title="9.PCB图生成PCB库："></a>9.PCB图生成PCB库：</h5><blockquote><p>   DP</p></blockquote><h5 id="10-安装孔："><a href="#10-安装孔：" class="headerlink" title="10.安装孔："></a>10.安装孔：</h5><blockquote><p>   取消 plated 非金属化   L切换3D</p></blockquote><h5 id="3DPCB"><a href="#3DPCB" class="headerlink" title="3DPCB"></a>3DPCB</h5><blockquote><p>   1.放置3D原件体模型——绘制3D模型——美化<br>    2.导入3d模型——点击放置3D原件体——TAB——右侧Generic——path选择路径<br>    3.3D模型网：<a href="http://www.3dcontentcentral.cn/">www.3dcontentcentral.cn</a></p></blockquote><h5 id="12-查找元器件"><a href="#12-查找元器件" class="headerlink" title="12.查找元器件"></a>12.查找元器件</h5><blockquote><p>   JC</p></blockquote><h5 id="13-PCB在元器件中导入在矩形框框中"><a href="#13-PCB在元器件中导入在矩形框框中" class="headerlink" title="13.PCB在元器件中导入在矩形框框中:"></a>13.PCB在元器件中导入在矩形框框中:</h5><blockquote><p>   TOL  设置成快捷键;ctrl+单击设置。</p></blockquote><h5 id="14-快捷键设置"><a href="#14-快捷键设置" class="headerlink" title="14.快捷键设置:"></a>14.快捷键设置:</h5><blockquote><p>   工具栏右击custmomize all 设置</p></blockquote><h5 id="15-隐藏布线："><a href="#15-隐藏布线：" class="headerlink" title="15.隐藏布线："></a>15.隐藏布线：</h5><blockquote><p>   NHA</p></blockquote><h5 id="16-对象类管理器："><a href="#16-对象类管理器：" class="headerlink" title="16.对象类管理器："></a>16.对象类管理器：</h5><blockquote><p>   DC,这里可以添加PWR的类，并将电源VCC,GND添加进成员列表。返回PCB,选择右下角的paneis里的PCB,作出可以单独显示电源线。</p></blockquote><h5 id="17-层叠管理器："><a href="#17-层叠管理器：" class="headerlink" title="17.层叠管理器："></a>17.层叠管理器：</h5><blockquote><p>   DK,可以添加层后保存。DSD板框定义，机械层画板框！</p></blockquote><h5 id="18-标尺"><a href="#18-标尺" class="headerlink" title="18.标尺"></a>18.标尺</h5><pre><code>CTRL+M 画标尺，SHIFT+C清除标尺</code></pre><h5 id="19-铜皮"><a href="#19-铜皮" class="headerlink" title="19.铜皮"></a>19.铜皮</h5><blockquote><p>   正片层：没有铜，划的线是铜 ，信号<br>    负片层：全是铜，画的线没有铜，电源，GND</p></blockquote><h5 id="20-两个界面的相互配合："><a href="#20-两个界面的相互配合：" class="headerlink" title="20.两个界面的相互配合："></a>20.两个界面的相互配合：</h5><blockquote><p>   交叉选择：连个界面分别都打开。<br>    设置里面，system里面的navigation里面有交叉选择模式和对象配置（变暗也建议勾选）</p></blockquote><h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>AD20还在学习中，最难的布局布线！加油</p>]]></content>
      
      
      
        <tags>
            
            <tag> AD20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，hexo</title>
      <link href="2021/04/05/text/"/>
      <url>2021/04/05/text/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到小李的博客！<br>本博客部署基于：hexo+github</p><span id="more"></span><h2 id="这是部署博客文章方式-快速开始"><a href="#这是部署博客文章方式-快速开始" class="headerlink" title="这是部署博客文章方式[快速开始]"></a>这是部署博客文章方式[快速开始]</h2><h3 id="建立新讯息"><a href="#建立新讯息" class="headerlink" title="建立新讯息"></a>建立新讯息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;我的新帖子&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="清除HTML文件"><a href="#清除HTML文件" class="headerlink" title="清除HTML文件"></a>清除HTML文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">清除HTML文件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-thread中关键词解释及部分API</title>
      <link href="2020/03/15/RT-thread_API/"/>
      <url>2020/03/15/RT-thread_API/</url>
      
        <content type="html"><![CDATA[<p>复习一下RTOS吧，本文完全参考<a href="https://www.bilibili.com/video/av79513262">RT_thread官方教程</a></p><span id="more"></span><h5 id="1-内存"><a href="#1-内存" class="headerlink" title="1.内存"></a>1.内存</h5><ol><li>栈stack：由编译器自动分配释放        比如   int a</li><li>堆heap：由程序员分配和释放   比如 malloc函数</li><li>动态内存空间：<strong>rt_system_heap_init(<em>begin_addr,<em>end_addr)</em></em></strong></li><li>动态内存申请<br>char <em>p;<br>p=(char</em>)rt_malloc(10);<br>rt_free( p);</li><li>内存复位：申请到的内存块，清零操作，确保没有东西在里面：<br>rt_memset(p,0,10);</li><li>内存泄漏解决方案：<br>malloc和free配套使用</li></ol><h5 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h5><ol><li>三部分组成：线程代码（入口函数），线程控制块，线程堆栈</li><li>入口函数：<br>void rtread_enter(viod *parameter）<br>{<br>}</li><li>动态线程的创建：rt_rtread_create();</li><li>详细参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">rt_thread_t</span> <span class="title">rt_thread_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *parameter)，</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *parameter, <span class="comment">//参数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">rt_uint_t</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">rt_uint8_t</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">rt_uint8_t</span> priority,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">rt_uint32_t</span> tick)</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动线程:<br>rt_err_t rt_thread_startup(rt_thread_t thread)</li></ol><h5 id="3-状态切换"><a href="#3-状态切换" class="headerlink" title="3.状态切换"></a>3.状态切换</h5><ol><li>就绪到挂起：suspend<br>挂起到关闭：delete，detach<br>运行到关闭：exit<h5 id="4-系统时钟"><a href="#4-系统时钟" class="headerlink" title="4.系统时钟"></a>4.系统时钟</h5></li><li>系统滴答定时器：心跳 100hz<br>HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq();<br>systick_cofing  滴答的频率第二个参数100<h5 id="5-gpio的架构"><a href="#5-gpio的架构" class="headerlink" title="5.gpio的架构"></a>5.gpio的架构</h5></li><li>void rt_pin_mode(rt_base_pin,mode)<h5 id="6-延时的api："><a href="#6-延时的api：" class="headerlink" title="6.延时的api："></a>6.延时的api：</h5></li><li>rt_thread_delay(50)<br>  rt_thread_mdelay(500)<br>  rt_rtthread_sleep(50)</li></ol><h5 id="7-事件片及优先级"><a href="#7-事件片及优先级" class="headerlink" title="7.事件片及优先级"></a>7.事件片及优先级</h5><ol><li>时间片参数：持有处理器时间长短的能力  时钟节拍为单位<br>优先级相同的情况下，时间片长占cpu时间长</li><li>优先级：线程竞争处理器资源的能力  256<br>最大设置:RT_THREAD_PRIORITY_MAX宏<br>stm32:32个</li></ol><h5 id="8-空闲线程和钩子函数"><a href="#8-空闲线程和钩子函数" class="headerlink" title="8.空闲线程和钩子函数"></a>8.空闲线程和钩子函数</h5><ol start="3"><li><p>空闲线程：系统线程，最低优先级<br>资源回收，移除关闭线程  idle.C</p></li><li><p>钩子函数:让系统在空闲线程的时候执行一些非紧急的事务，比如让LED灯闪烁等<br>设置：rt_err_t rt_thread_idle_sethook(void(*hook)(void))<br>删除：rt_err_t rt_thread_idle_delhook(void(*hook)(void))<br>钩子函数不能够被挂起</p></li><li><p>系统调度钩子函数：任务切换时运行，打印调度信息<br>rt_scheduler_sethook(void(*hook)(struct rt_thread *from,struct rt_thread *to)<br>rt_err_t rt_thread_idle_delhook(void(*hook)(void））</p><h5 id="9-临界"><a href="#9-临界" class="headerlink" title="9. 临界"></a>9. 临界</h5></li><li><p>临界资源：一次仅允许一个线程访问的共享资源，他可以是一个具体的硬件设备，也可以是变量，缓冲区</p></li><li><p>临界区：每个线程中访问（操作）临界资源的那段代码称为临界区，我们只允许一个线程进入临界区</p></li><li><p>两种保护方式：<br> 1：关闭系统调度保护临界区：把调度器锁住，不让进行调度<br>rt_enter_critical();</p><p>rt_exit_critical();</p><p>2：关闭中断保护临界区：任务调度都是建立在中断的基础上的<br>rt_base_t lever;<br>lever = rt_hw_interrupt_disable();<br>rt_hw_interrupt_enable();</p><h5 id="10-IPC"><a href="#10-IPC" class="headerlink" title="10.IPC"></a>10.IPC</h5><p>进程间通信<br>信号量，互斥量，事件，邮箱，消息队列</p></li></ol><h5 id="11-信号量"><a href="#11-信号量" class="headerlink" title="11.信号量"></a>11.信号量</h5><p>停车厂管理</p><ol><li>控制块定义</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rt_semaphore</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> rt_ipc_object parent;                 </span><br><span class="line">    rt_uint16_t          <span class="keyword">value</span>;  </span><br><span class="line">&#125;;</span><br><span class="line">typedef   <span class="keyword">struct</span> rt_semaphore     *rt_sem_t;</span><br><span class="line"></span><br><span class="line">静态：<span class="keyword">struct</span> rt_semaphore  static_sem</span><br><span class="line">动态：rt_sem_t dynamic_sem</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>静态信号量的操作初始化与脱离</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_init</span>(<span class="params">rt_sem_t    sem,   //信号量指针</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="built_in">char</span> *name,         //信号量名称</span></span></span><br><span class="line"><span class="function"><span class="params">                     rt_uint32_t <span class="keyword">value</span>,          //初始值</span></span></span><br><span class="line"><span class="function"><span class="params">                     rt_uint8_t  flag</span>)</span>;              <span class="comment">//标志</span></span><br></pre></td></tr></table></figure><p>flag：<br>    RT_IPC_FLAG_FIFO  先进先出排队<br>    RT_IPC_FALG_PRIO     优先级排队</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_detach</span>(<span class="params">rt_sem_t sem</span>)</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li> 动态信号量的创建与删除</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rt_sem_t <span class="title">rt_sem_create</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *name, rt_uint32_t <span class="keyword">value</span>, rt_uint8_t flag</span>)</span>;</span><br><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_delete</span>(<span class="params">rt_sem_t sem</span>)</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取信号量</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_take</span>(<span class="params">rt_sem_t sem, rt_int32_t time</span>)</span>;</span><br><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_trytake</span>(<span class="params">rt_sem_t sem</span>)</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>释放</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">rt_err_t <span class="title">rt_sem_release</span>(<span class="params">rt_sem_t sem</span>)</span>;</span><br></pre></td></tr></table></figure><h5 id="12-生产和消费者关系"><a href="#12-生产和消费者关系" class="headerlink" title="12.生产和消费者关系"></a>12.生产和消费者关系</h5><p>生产者和消费者关系：同步2个信号量和互斥1个信号量<br>空，满<br>两只手：空位一手放东西，满位一手告诉对方是否可以拿</p><h5 id="13-互斥量的使用："><a href="#13-互斥量的使用：" class="headerlink" title="13.互斥量的使用："></a>13.互斥量的使用：</h5><p>线程间的互斥访问</p><ol><li>互斥量控制块：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rt_ipc_object</span> <span class="title">parent</span>;</span></span><br><span class="line">  <span class="keyword">rt_unint16_t</span> value;</span><br><span class="line">  <span class="keyword">rt_uint8_t</span> original_priority;</span><br><span class="line">  <span class="keyword">rt_uint8_t</span> hold;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">定义静态：<span class="class"><span class="keyword">struct</span> _<span class="title">rt_mutex</span> <span class="title">static_mutex</span></span></span><br><span class="line"><span class="class">定义动态：<span class="title">rt_mutex_t</span> <span class="title">dynamic_mutex</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><ol start="2"><li>注意：只有由持有他的线程释放！</li></ol><h5 id="14-线程的优先级翻转"><a href="#14-线程的优先级翻转" class="headerlink" title="14.线程的优先级翻转"></a>14.线程的优先级翻转</h5><p>高优先级的线程，用到的资源是低优先级的资源。则先去执行低优先级的任务，然后又更加优先级，去执行中优先级的任务。</p><h5 id="15-优先级继承："><a href="#15-优先级继承：" class="headerlink" title="15.优先级继承："></a>15.优先级继承：</h5><p>把低优先级任务的优先级提高和高优先级任务的优先级一样。</p><h5 id="16-事件集event"><a href="#16-事件集event" class="headerlink" title="16.事件集event"></a>16.事件集event</h5><p>一个32位的数，每一位代表一个信号量，接收事件位有：与或方式</p><h5 id="17-邮箱mailbox"><a href="#17-邮箱mailbox" class="headerlink" title="17.邮箱mailbox"></a>17.邮箱mailbox</h5><p>一个线程往邮箱里发送数据or地址，另一个线程从邮箱中拿出来使用。</p><h5 id="18-消息队列："><a href="#18-消息队列：" class="headerlink" title="18.消息队列："></a>18.消息队列：</h5><p>对邮箱的扩展，接收来自线程和中断服务例程的不固定长度消息，并保存在自己内存，其他线程可以从消息队列中读取消息并进行处理。</p><ol><li>链表头，链表尾，空闲链表。<br>紧急消息放在消息头，一般消息放空闲链表。</li><li>消息队列控制块：struct rt_messsagequeue<h5 id="19-软件定时器：系统节拍（os-tick）"><a href="#19-软件定时器：系统节拍（os-tick）" class="headerlink" title="19.软件定时器：系统节拍（os tick）"></a>19.软件定时器：系统节拍（os tick）</h5>中断环境：HARDTIMER模式<br>TIMER线程：SOFTTIMER模式<h5 id="20-内存池"><a href="#20-内存池" class="headerlink" title="20.内存池"></a>20.内存池</h5>内存资源分配.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git&amp;github使用小笔记</title>
      <link href="2020/03/10/git-github_NOTE/"/>
      <url>2020/03/10/git-github_NOTE/</url>
      
        <content type="html"><![CDATA[<p>git&amp;github使用笔记，先记着以后忘了方便粘贴！</p><span id="more"></span><h4 id="1-在电脑安装好git后配置"><a href="#1-在电脑安装好git后配置" class="headerlink" title="1. 在电脑安装好git后配置:"></a>1. 在电脑安装好git后配置:</h4><p>右击鼠标右键点开”Git Bash Here”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>可以去掉后面的引号及里面的东西，再次输入命令可以查看当前配置信息。<br>比如：<em><strong>git config –global user.name</strong></em> </p><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化:"></a>2.初始化:</h4><p>创建一个文件夹进入里面执行 “git init”创建了一个仓库，管理这个文件夹里面的东西，里面有隐藏文件夹 .git 里面是配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h4 id="3-查看文件状态："><a href="#3-查看文件状态：" class="headerlink" title="3.查看文件状态："></a>3.查看文件状态：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="4-添加到缓存区中："><a href="#4-添加到缓存区中：" class="headerlink" title="4.添加到缓存区中："></a>4.添加到缓存区中：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add 文件1</span><br><span class="line">git add 文件1 文件2 文件3 .......</span><br><span class="line">git.    //添加当前目录</span><br></pre></td></tr></table></figure><h4 id="5-提交到版本库"><a href="#5-提交到版本库" class="headerlink" title="5.提交到版本库:"></a>5.提交到版本库:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m “注释”</span><br></pre></td></tr></table></figure><h4 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6.版本回退"></a>6.版本回退</h4><ol><li>查看版本号:两种显示方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=online</span><br></pre></td></tr></table></figure></li><li>回到过去再回来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog  </span><br></pre></td></tr></table></figure></li><li>回退操作</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><h4 id="7-仓库的两种管理方式"><a href="#7-仓库的两种管理方式" class="headerlink" title="7.仓库的两种管理方式"></a>7.仓库的两种管理方式</h4><ol><li>https：</li></ol><ul><li><input disabled="" type="checkbox"> 先创建线上和本地仓库</li><li><input disabled="" type="checkbox"> 克隆线上仓库到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  被克隆的线上仓库地址</span><br><span class="line">git  add    目录</span><br><span class="line">git commit -m “注释”</span><br><span class="line">git push   提交线上仓库</span><br></pre></td></tr></table></figure><p>配置.git/config再url中加入用户名和密码<br><strong>url = https://用户名：密码@github.com/用户名/仓库名.git</strong></p><ol><li>ssh：</li><li><input disabled="" type="checkbox"> 先安装好openssh</li><li><input disabled="" type="checkbox"> 本地创建公私钥对文件</li><li><input disabled="" type="checkbox"> <code>ssh-keygen -t rsa -C &quot;liai@qq.mail&quot;</code></li><li><input disabled="" type="checkbox"> 连续回车，.pub为公钥</li><li><input disabled="" type="checkbox"> 上传公钥保存：克隆那里添加公钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  被克隆的线上仓库地址</span><br><span class="line">git  add    目录</span><br><span class="line">git commit -m “注释”</span><br><span class="line">git push   提交线上仓库</span><br></pre></td></tr></table></figure><h4 id="8-分支管理"><a href="#8-分支管理" class="headerlink" title="8.分支管理"></a>8.分支管理</h4></li><li>查看分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch   </span><br></pre></td></tr></table></figure></li><li>创建分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchName&gt;</span><br></pre></td></tr></table></figure></li><li>切换分支:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>创建新分支&lt;分支名&gt;并切换到新的分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>合并某分支到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;被合并的分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除分支：要退出被删分支</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="9-使用前："><a href="#9-使用前：" class="headerlink" title="9.使用前："></a>9.使用前：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="10-忽略文件："><a href="#10-忽略文件：" class="headerlink" title="10.忽略文件："></a>10.忽略文件：</h4><ol><li>touch .gitignore文件：生效与当前目录和子目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure></li><li>过滤编辑规则：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#过滤文件夹</span></span><br><span class="line">/js/</span><br><span class="line"><span class="comment">#过滤所有.ZIP包</span></span><br><span class="line">*.zip</span><br><span class="line"><span class="comment">#过滤某具体个文件</span></span><br><span class="line">/js/index.php</span><br><span class="line"><span class="comment">#不过滤某个文件</span></span><br><span class="line">！index.php</span><br></pre></td></tr></table></figure><p>！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> git&amp;github </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32的485通讯传感器采集程序</title>
      <link href="2020/02/23/STM32&amp;&amp;RS485/"/>
      <url>2020/02/23/STM32&amp;&amp;RS485/</url>
      
        <content type="html"><![CDATA[<p>先来看看硬件连接，大致就这样连接！</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20200222233743726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VBeWF5YXlh,size_16,color_FFFFFF,t_70" alt="485硬件大致流程" loading="lazy"><br>一般来说，RS485是硬件，而他软件方面是modbus协议，用到最多的是RTU方式。</p><p>工作方式：主机（STM32)通过串口向从机发送一段问询帧（包括地址码，功能码，数据码，效验码），每个从机（485传感器）都可以收到，但是因为问询帧里面有一段地址码，所以只有对应的地址的从机才执行相应的命令（比如返回采集到的温湿度等），然后主机就可以接收来自从机的问询帧解析相应的数据码即可。</p><p>了解通信流程，来看看代码！！省略的串口配置，时钟配置等</p><p>1.定义问询帧，具体看你的传感器的数据手册<br><img src="https://img-blog.csdnimg.cn/20200222233903119.png" alt="数据帧定义" loading="lazy"><br>2.485问询函数<br><img src="https://img-blog.csdnimg.cn/20200222234016829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VBeWF5YXlh,size_16,color_FFFFFF,t_70" alt="485" loading="lazy"><br>3.CRC效验函数<br><img src="https://img-blog.csdnimg.cn/20200222234124232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VBeWF5YXlh,size_16,color_FFFFFF,t_70" alt="crc" loading="lazy"><br>4.数据处理函数<br><img src="https://img-blog.csdnimg.cn/2020022223421159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VBeWF5YXlh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>解释：可以一个函数完成数据发送与接收和校验！<br>原理分析：在设备串口问询485数据后，会立即进入接收串口接收中断，同时将接收的数据存入结构体，然后进行返回值除去后两位的CRC校验判断是否与返回的数据相等，如果满足CRC校验，就确认为正常数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> RS485 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD20学习笔记二</title>
      <link href="2020/02/14/AD20note1/"/>
      <url>2020/02/14/AD20note1/</url>
      
        <content type="html"><![CDATA[<p>继续整理</p><span id="more"></span><h5 id="21-导入CAD板框结构，"><a href="#21-导入CAD板框结构，" class="headerlink" title="21.导入CAD板框结构，"></a>21.导入CAD板框结构，</h5><blockquote><p>   FI里面的DXF/DWG，选中文件路径， 设置比例mm,1:1,全选PCB层导入机械二层，点击确定。</p></blockquote><h5 id="22-板框定义"><a href="#22-板框定义" class="headerlink" title="22.板框定义"></a>22.板框定义</h5><blockquote><p>   选中一根线，按TAB，相连接的线全部选中，切换到机械一层，shift+s选中板框按DSD</p></blockquote><h5 id="23-安装孔："><a href="#23-安装孔：" class="headerlink" title="23.安装孔："></a>23.安装孔：</h5><blockquote><p>   取消 plated 非金属化   L切换3D，选中MS移动。</p></blockquote><h5 id="24-忽略同一封装内的焊盘间距："><a href="#24-忽略同一封装内的焊盘间距：" class="headerlink" title="24. 忽略同一封装内的焊盘间距："></a>24. 忽略同一封装内的焊盘间距：</h5><blockquote><p>   DR——Electrical选项下的Clearance中的忽略焊盘间距。</p></blockquote><h5 id="25-丝印变小："><a href="#25-丝印变小：" class="headerlink" title="25. 丝印变小："></a>25. 丝印变小：</h5><blockquote><p>   选中一个丝印，右击查找相似对象，更改text height和Stroke Windth的值推荐10，5moil。CTRL+A全选，AP改变标识符位置。</p></blockquote><h5 id="26-布局技巧"><a href="#26-布局技巧" class="headerlink" title="26.布局技巧"></a>26.布局技巧</h5><blockquote><p>   先根据信号线，各个模块，大致确定大写器件（mcu，插接件) ,然后根据原理图确定小期间的位置，高亮元件信号走向，优化位置，方向等。</p></blockquote><h5 id="27-器件移层"><a href="#27-器件移层" class="headerlink" title="27.器件移层"></a>27.器件移层</h5><blockquote><p>   拖动状态下按L 从顶层移到底层</p></blockquote><h5 id="28-晶振"><a href="#28-晶振" class="headerlink" title="28.晶振"></a>28.晶振</h5><blockquote><p>   晶振的Π型滤波，晶振+2个电阻。晶振边框要用接地线包围，AGND是模拟地，和GND要分开。</p></blockquote><h5 id="29-PCB图在原理图中找到对应原件"><a href="#29-PCB图在原理图中找到对应原件" class="headerlink" title="29.PCB图在原理图中找到对应原件"></a>29.PCB图在原理图中找到对应原件</h5><blockquote><p>   TC，在分割界面中更好用</p></blockquote><h5 id="30-原理图有问题"><a href="#30-原理图有问题" class="headerlink" title="30.原理图有问题"></a>30.原理图有问题</h5><blockquote><p>   如果发现pcb布局中发现原理图有问题，可以直接在原理图中更改，然后重新导入pcb图中。</p></blockquote><h5 id="31-规则设置"><a href="#31-规则设置" class="headerlink" title="31.规则设置"></a>31.规则设置</h5><blockquote><p>   布线规则设置 DR </p></blockquote><pre><code>1.间距规则(all, 过孔-铜皮，铜皮到all，6mil推荐  4mil）2.线宽规则  优先级设置（信号线宽（阻抗50Ω，456moil），电源线款加粗15moil，差分线（类创建DC，在differential part classes 中添加类90，100  ，确定后点卡右下角的PCB,第一个选项选到，在differential part editor，选中类添加信号或者从网络创建+ -  p nm点规则向导575757+  ）6 4 5）3.覆铜规则：覆铜方式：规则里面 plane --    第三个正片 ——连接方式  —— 花焊盘（自己焊接）  全连接（推荐） 不连接     第二个负片层选7MOIL4.阻焊一般设置2.5moil    绿油墙4moil以上， 5.丝印规则 ：规则——manufacturing——silk to solder ——对象与丝印最小间距 2MOIL</code></pre><h5 id="32-关于过孔"><a href="#32-关于过孔" class="headerlink" title="32.关于过孔"></a>32.关于过孔</h5><blockquote><p>   1.先打孔占位，12.24moil 盖油勾选：低顶 tented，tented<br>    2.更改默认过孔：设置——PCB editor——Defaults——via</p></blockquote><h5 id="33-铺铜问题"><a href="#33-铺铜问题" class="headerlink" title="33.铺铜问题"></a>33.铺铜问题</h5><blockquote><p>   1.全连接情况下，发现没有全部连接，选中铜皮，设置pour over all net 和勾选 remover dead copper 。<br>    2.更改默认过孔：设置——PCB editor——Defaults——polygon3</p></blockquote><h5 id="34-自动布线："><a href="#34-自动布线：" class="headerlink" title="34 自动布线："></a>34 自动布线：</h5><blockquote><p>   自动布线： paneis—&gt;pcb Activeoute<br>    1.第一个选项:Tune selectd勾选，ALT+按住鼠标左上拖动选中要布的线，然后布线 Activeroute<br>    2.第三个选项：布线向导，可以选中要布线的层，可以打过孔。</p></blockquote><h5 id="35-走线"><a href="#35-走线" class="headerlink" title="35.走线"></a>35.走线</h5><blockquote><p>   1.只是显示器件的信号走线：选中器件，N显示器件，选中电源连接隐藏。<br>    2.um多根走线，<br>    3.shift+r忽略障碍物走线<br>    4.DM复位DRC</p></blockquote><h5 id="36-关于电源铺铜"><a href="#36-关于电源铺铜" class="headerlink" title="36.关于电源铺铜"></a>36.关于电源铺铜</h5><blockquote><p>   模拟地丶电源和数字地丶电源不一样，在负片层隔离。双击隔离区添加网络。</p></blockquote><h5 id="37-减少干扰"><a href="#37-减少干扰" class="headerlink" title="37.减少干扰"></a>37.减少干扰</h5><blockquote><p>   1.RJ45干扰抑制方法:挖空所有层,P——&gt;多边形矩形挖空<br>    2.打孔换层的地方放过孔gnd<br>    3.缝合GND孔：THA,约束区域——栅格150mil——大小12.22——选择网络GND——强制盖油——确定（前提覆铜了）<br>    4.底层和顶层覆铜！！</p></blockquote><h5 id="38-丝印调整"><a href="#38-丝印调整" class="headerlink" title="38.丝印调整"></a>38.丝印调整</h5><blockquote><p>   1.选中一个丝印，右击——查找相似对象——第一个选项选择same确定——大小30.5mil（6倍）<br>    2.选中一个元件，只打开器件选择，全选器件，AP调整丝印位置<br>    3.右下角的paneis——view可以只选择某一层观看。<br>    4.视图V下可以翻转板子</p></blockquote><h5 id="39-LOGO"><a href="#39-LOGO" class="headerlink" title="39.LOGO"></a>39.LOGO</h5><blockquote><p>   1.LOGO变成单色位图——导入——转换——paneis——properties——选择logo——更改层为topoverlay<br>    2.全选LOGO右击——联合，再次选择联合并调整大小。<br>    3.在丝印层添加标识：丝印层添加字符串——格式改为turn type</p></blockquote><h5 id="40DRC检查"><a href="#40DRC检查" class="headerlink" title="40DRC检查"></a>40DRC检查</h5><blockquote><p>   TD——停止监测选择大一点——选择规则——运行</p></blockquote><h5 id="41整理资料"><a href="#41整理资料" class="headerlink" title="41整理资料"></a>41整理资料</h5><blockquote><p>   各层加注释，在机械层加测量</p></blockquote><pre><code>1.gerber文件输出    FF——gerber Files——通用英寸比例2：4——绘制层选择已使用的——镜像层选择全部去掉——层机械一层上面的全选中——选中未连接的中间层焊盘——钻孔图层——全选大选项——高级——xyz加一个0——确定——pameis——CAMtastic     2.钻孔文件    FF——NC Drill files——确定3.ipc网表    FF——test point report——格式选择IPC——确定上面3项可以不保存，4.装配图:    FM——当前文档——next——pab打印设置——右击第一个大选项——创建Assmbly Drawings5.bom表    报告R的第一个选项——选择输出内容——输出格式，模板——export6.坐标文件：    FB——generates pick。。。——默认——确定。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> AD20 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
